<!-- views/index.ejs -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Real-time Text Share</title>
    <link rel="stylesheet" href="/style.css" />
    <script src="/qrcode.min.js"></script>
    <link
      id="favicon"
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg%20id%3D%22svg%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22128%22%20height%3D%22128%22%20viewBox%3D%220%200%20128%20128%22%20align%3D%22center%22%3E%3Ctext%20x%3D%2264%22%20y%3D%2274%22%20dominant-baseline%3D%22middle%22%20text-anchor%3D%22middle%22%20font-size%3D%22100%22%20font-family%3D%22sans-serif%22%20fill%3D%22%23000000%22%20font-weight%3D%22normal%22%3E%F0%9F%8F%B9%3C%2Ftext%3E%3C%2Fsvg%3E"
    />
  </head>
  <body>
    <div class="container">
      <div id="header">
        <h1>Real-time Text & Image Share</h1>
        <div>
          <div><a href="/" class="button">New Room</a></div>
          <div id="qrcode"></div>
        </div>
      </div>
      <textarea
        id="sharedText"
        placeholder="Start typing to share..."
      ></textarea>
      <div class="textarea-barcode-controls">
        <button class="button" id="generate-barcodes">
          Generate QRCodes for Text
        </button>
        <button id="close-barcodes" title="Hide QR Codes" style="display: none">
          âœ•
        </button>
      </div>
      <div class="barcodes"></div>
      <div id="image-share">
        <h2>Images</h2>
        <form id="imageUploadForm" enctype="multipart/form-data">
          <input
            type="file"
            id="imageInput"
            name="image"
            accept="image/png,image/jpeg,image/webp"
            style="display: none"
          />
          <div id="dropArea">
            Drag & Drop or
            <button type="button" id="selectImageBtn">Select Image</button>
          </div>
        </form>
        <div id="sharedImages"></div>
        <!-- Upload status indicator -->
        <div
          id="uploadStatus"
          style="display: none; margin: 0.5rem 0; text-align: center"
        ></div>
      </div>
      <div class="users-info">
        <p>Connected Users: <span id="userCount">0</span></p>
        <ul id="userList"></ul>
        <p class="privacy-note">
          Your IP address will be visible to other users in this room.
        </p>
      </div>
      <footer class="footer">
        <p>
          <a href="https://github.com/andygock/text-share" target="_blank"
            >GitHub</a
          >
        </p>
      </footer>
    </div>
    <div id="userCountSticky">
      Users: <span id="userCountStickyNum">0</span>
    </div>

    <script>
      (function () {
        //
        // qrcode generation
        //

        function generateTextAreaBarcodes() {
          // generate barcodes, one qrcode per line in the textarea, ignore white space only lines
          const lines = sharedTextarea.value.split("\n");
          const barcodesDiv = document.querySelector(".barcodes");
          barcodesDiv.innerHTML = ""; // Clear existing barcodes

          lines.forEach((line) => {
            const trimmedLine = line.trim();
            if (trimmedLine) {
              const barcodeDiv = document.createElement("div");
              barcodeDiv.className = "barcode-item";
              barcodesDiv.appendChild(barcodeDiv);
              new QRCode(barcodeDiv, {
                text: trimmedLine,
                width: 128,
                height: 128,
                colorDark: "#000",
                colorLight: "#fff",
                correctLevel: QRCode.CorrectLevel.H,
              });

              // add text under the barcode
              const textDiv = document.createElement("div");
              textDiv.className = "barcode-text";
              textDiv.textContent = trimmedLine;
              barcodeDiv.appendChild(textDiv);
            }
          });
        }

        const barcodesDiv = document.querySelector(".barcodes");
        const generateBarcodesButton =
          document.getElementById("generate-barcodes");
        const closeBarcodesButton = document.getElementById("close-barcodes");

        generateBarcodesButton.addEventListener("click", () => {
          generateTextAreaBarcodes();
          generateBarcodesButton.dataset.hash = inputHash;
          generateBarcodesButton.disabled = true;
          closeBarcodesButton.style.display = "inline-block";
          barcodesDiv.style.display = "block";
        });

        closeBarcodesButton.addEventListener("click", () => {
          barcodesDiv.innerHTML = "";
          barcodesDiv.style.display = "none";
          closeBarcodesButton.style.display = "none";
          generateBarcodesButton.disabled = false;
        });

        //
        // input text and room handling
        //

        const roomId = "<%= roomId %>";
        const protocol = window.location.protocol === "https:" ? "wss" : "ws";
        const websocket = new WebSocket(
          `${protocol}://${window.location.host}/${roomId}`
        );
        const sharedTextarea = document.getElementById("sharedText");
        const qrcodeDiv = document.getElementById("qrcode");
        const userCountSpan = document.getElementById("userCount");
        const userCountStickyNum =
          document.getElementById("userCountStickyNum");
        const userListUl = document.getElementById("userList");

        let inputHash = "";

        function crc32(str) {
          // CRC32 hash function
          let crc = 0xffffffff;
          for (let i = 0; i < str.length; i++) {
            crc ^= str.charCodeAt(i);
            for (let j = 0; j < 8; j++) {
              crc = (crc >>> 1) ^ (crc & 1 ? 0xedb88320 : 0);
            }
          }
          return (crc ^ 0xffffffff) >>> 0;
        }

        function updateHash(str) {
          // generate crc32 hash of the string
          const hash = crc32(str);
          inputHash = hash;
        }

        // Generate QR Code for url
        const currentUrl = window.location.href;
        new QRCode(qrcodeDiv, {
          text: currentUrl,
          width: 128,
          height: 128,
          colorDark: "#000",
          colorLight: "#fff",
          correctLevel: QRCode.CorrectLevel.H,
        });

        // send message to server when user types in textarea
        sharedTextarea.addEventListener("input", () => {
          websocket.send(sharedTextarea.value);
          updateHash(sharedTextarea.value);
          generateBarcodesButton.disabled = false;
        });

        // receive message from server (single handler for all message types)
        websocket.onmessage = (event) => {
          let message;
          try {
            message = JSON.parse(event.data);
          } catch {
            // Not JSON, ignore
            return;
          }
          if (message.type === "textUpdate") {
            sharedTextarea.value = message.text;
            updateHash(message.text);
            generateBarcodesButton.disabled = false;
          } else if (message.type === "userList") {
            updateUserList(message.users);
          } else if (message.type === "userConnected") {
            addUser(message.ip);
          } else if (message.type === "userDisconnected") {
            removeUser(message.ip);
          } else if (message.type === "imageUploadStart") {
            incomingImage = null;
            incomingChunks = [];
            incomingTotalChunks = 0;
            incomingFilename = message.filename;
            incomingMimeType = message.mimeType;
            uploadStatus.style.display = "block";
            uploadStatus.textContent = `Receiving image: ${incomingFilename}`;
          } else if (message.type === "imageUploadChunk") {
            if (message.filename !== incomingFilename) return;
            incomingChunks[message.chunkIndex] = message.data;
            incomingTotalChunks = message.totalChunks;
          } else if (message.type === "imageUploadProgress") {
            if (message.filename === incomingFilename) {
              uploadStatus.textContent = `Receiving... ${message.progress}%`;
            }
          } else if (message.type === "imageUploadComplete") {
            if (message.filename !== incomingFilename) return;
            // Use processed image data
            const base64 = message.data;
            const img = document.createElement("img");
            img.src = `data:${message.mimeType};base64,${base64}`;
            img.alt = message.filename;
            img.title = `${message.filename} (${message.width}x${
              message.height
            }, ${Math.ceil(message.size / 1024)}kB)`;
            img.style.maxWidth = "100%";
            img.style.maxHeight = "300px";
            const info = document.createElement("div");
            info.textContent = `${message.filename} (${message.width}x${
              message.height
            }, ${Math.ceil(message.size / 1024)}kB)`;
            const wrapper = document.createElement("div");
            wrapper.className = "shared-image-item";
            wrapper.appendChild(img);
            wrapper.appendChild(info);
            sharedImages.appendChild(wrapper);
            uploadStatus.textContent = "Image received.";
            setTimeout(() => (uploadStatus.style.display = "none"), 2000);
            incomingImage = null;
            incomingChunks = [];
            incomingTotalChunks = 0;
            incomingFilename = "";
            incomingMimeType = "";
          } else if (message.type === "imageUploadError") {
            uploadStatus.textContent = `Error: ${message.error}`;
            setTimeout(() => (uploadStatus.style.display = "none"), 3000);
          }
        };

        // Track user count for upload enable/disable
        let userCount = 0;
        function setImageUploadEnabled(enabled) {
          imageInput.disabled = !enabled;
          selectImageBtn.disabled = !enabled;
          dropArea.style.pointerEvents = enabled ? "auto" : "none";
          dropArea.style.opacity = enabled ? "1" : "0.5";
          const infoMsgId = "image-upload-info-msg";
          let infoMsg = document.getElementById(infoMsgId);
          if (!enabled) {
            dropArea.title =
              "You must have at least 2 users in the room to upload images.";
            selectImageBtn.title =
              "You must have at least 2 users in the room to upload images.";
            if (!infoMsg) {
              infoMsg = document.createElement("div");
              infoMsg.id = infoMsgId;
              infoMsg.style.color = "#a94442";
              infoMsg.style.fontSize = "0.95rem";
              infoMsg.style.margin = "0.5rem 0 0.5rem 0";
              infoMsg.style.textAlign = "center";
              infoMsg.textContent =
                "You cannot upload images because there is no one else connected to this room.";
              document
                .getElementById("image-share")
                .insertBefore(infoMsg, document.getElementById("sharedImages"));
            } else {
              infoMsg.style.display = "block";
            }
          } else {
            dropArea.title = "";
            selectImageBtn.title = "Select Image";
            if (infoMsg) infoMsg.style.display = "none";
          }
        }

        function updateUserList(users) {
          userListUl.innerHTML = ""; // Clear existing list
          users.forEach((ip) => addUserToList(ip));
          userCountSpan.textContent = users.length;
          userCountStickyNum.textContent = users.length;
          userCount = users.length;
          setImageUploadEnabled(userCount > 1);
        }

        function addUser(ip) {
          addUserToList(ip);
          userCount = parseInt(userCountSpan.textContent) + 1;
          userCountSpan.textContent = userCount;
          userCountStickyNum.textContent = userCount;
          setImageUploadEnabled(userCount > 1);
        }

        function removeUser(ip) {
          removeUserFromList(ip);
          userCount = parseInt(userCountSpan.textContent) - 1;
          userCountSpan.textContent = userCount;
          userCountStickyNum.textContent = userCount;
          setImageUploadEnabled(userCount > 1);
        }

        function addUserToList(ip) {
          const li = document.createElement("li");
          li.textContent = ip;
          li.dataset.ip = ip; // Store IP for easy removal
          userListUl.appendChild(li);
        }

        function removeUserFromList(ip) {
          const userLi = userListUl.querySelector(`li[data-ip="${ip}"]`);
          if (userLi) {
            userListUl.removeChild(userLi);
          }
        }

        //
        // Image sharing logic
        //

        const imageInput = document.getElementById("imageInput");
        const selectImageBtn = document.getElementById("selectImageBtn");
        const dropArea = document.getElementById("dropArea");
        const sharedImages = document.getElementById("sharedImages");
        let uploadStatus = document.getElementById("uploadStatus");
        if (!uploadStatus) {
          uploadStatus = document.createElement("div");
          uploadStatus.id = "uploadStatus";
          uploadStatus.style.display = "none";
          uploadStatus.style.margin = "0.5rem 0";
          uploadStatus.style.textAlign = "center";
          document
            .getElementById("image-share")
            .insertBefore(uploadStatus, sharedImages);
        }
        let uploadProgressBar = document.getElementById("uploadProgressBar");
        if (!uploadProgressBar) {
          uploadProgressBar = document.createElement("progress");
          uploadProgressBar.id = "uploadProgressBar";
          uploadProgressBar.max = 100;
          uploadProgressBar.value = 0;
          uploadProgressBar.style.display = "none";
          uploadProgressBar.style.width = "60%";
          uploadStatus.appendChild(uploadProgressBar);
        }

        // --- Image sharing logic via WebSocket ---
        // Use only one declaration for each DOM element at the top scope
        // These are already declared above, so just use them here
        // const imageInput = document.getElementById("imageInput");
        // const selectImageBtn = document.getElementById("selectImageBtn");
        // const dropArea = document.getElementById("dropArea");
        // const sharedImages = document.getElementById("sharedImages");
        // const uploadStatus = document.getElementById("uploadStatus");

        // Helper: split buffer into base64 chunks
        function splitBase64IntoChunks(base64, chunkSize) {
          const chunks = [];
          for (let i = 0; i < base64.length; i += chunkSize) {
            chunks.push(base64.slice(i, i + chunkSize));
          }
          return chunks;
        }

        // Upload image via WebSocket
        async function uploadImage(file) {
          uploadStatus.style.display = "block";
          uploadStatus.textContent = "Processing image...";
          // Read file as ArrayBuffer
          const arrayBuffer = await file.arrayBuffer();
          // Send start message
          websocket.send(
            JSON.stringify({
              type: "imageUploadStart",
              filename: file.name,
              mimeType: file.type,
              size: file.size,
            })
          );
          // Convert to base64
          const base64 = btoa(
            new Uint8Array(arrayBuffer).reduce(
              (data, byte) => data + String.fromCharCode(byte),
              ""
            )
          );
          // Chunk size: 32k chars (24kB per chunk)
          const chunkSize = 32 * 1024;
          const chunks = splitBase64IntoChunks(base64, chunkSize);
          for (let i = 0; i < chunks.length; i++) {
            websocket.send(
              JSON.stringify({
                type: "imageUploadChunk",
                filename: file.name,
                chunkIndex: i,
                totalChunks: chunks.length,
                data: chunks[i],
              })
            );
            // Show progress
            const percent = Math.round(((i + 1) / chunks.length) * 100);
            uploadStatus.textContent = `Uploading... ${percent}%`;
            await new Promise((r) => setTimeout(r, 10)); // allow UI update
          }
        }

        // Handle file input
        selectImageBtn.addEventListener("click", () => imageInput.click());
        imageInput.addEventListener("change", (e) => {
          if (e.target.files && e.target.files[0]) {
            uploadImage(e.target.files[0]);
          }
        });
        dropArea.addEventListener("drop", (e) => {
          e.preventDefault();
          dropArea.classList.remove("dragover");
          if (e.dataTransfer.files && e.dataTransfer.files[0]) {
            uploadImage(e.dataTransfer.files[0]);
          }
        });
        dropArea.addEventListener("dragover", (e) => {
          e.preventDefault();
          dropArea.classList.add("dragover");
        });
        dropArea.addEventListener("dragleave", () =>
          dropArea.classList.remove("dragover")
        );

        websocket.onopen = () => {
          console.log("WebSocket connection opened");
        };

        websocket.onclose = () => {
          console.log("WebSocket connection closed");
        };

        websocket.onerror = (error) => {
          console.error("WebSocket error:", error);
        };

        // On page load, disable upload if only one user
        setImageUploadEnabled(false);
      })();
    </script>
  </body>
</html>
